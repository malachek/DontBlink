// (c) Meta Platforms, Inc. and affiliates. Confidential and proprietary.
// Copyright Epic Games, Inc. All Rights Reserved.
#include "MetaXRAcousticMap.h"
#include "AudioDevice.h"
#include "Engine/StaticMesh.h"
#include "EngineUtils.h"
#include "HAL/PlatformFileManager.h"
#include "IMetaXRAudioPlugin.h"
#include "Materials/MaterialInstanceDynamic.h"
#include "MetaXRAcousticGeometry.h"
#include "MetaXRAcousticMaterial.h"
#include "MetaXRAcousticProjectSettings.h"
#include "MetaXRAudioContext.h"
#include "MetaXRAudioLogging.h"
#include "MetaXRAudioUtilities.h"
#include "Misc/FileHelper.h"
#include "Runtime/Core/Public/Serialization/CustomVersion.h"

#include "Misc/EngineVersionComparison.h"
#if UE_VERSION_OLDER_THAN(5, 2, 0)
#include "MaterialShared.h"
#else
#include "Materials/MaterialRenderProxy.h"
#endif
#if WITH_EDITOR
#include "Components/InstancedStaticMeshComponent.h"
#include "Templates/UnrealTypeTraits.h"
#endif

#define WITH_EDITOR_GIZMOS (WITH_EDITOR && WITH_EDITORONLY_DATA)
#define UE_ACOUSTIC_MAP_FILE_EXTENSION ".xramap"

#if WITH_EDITOR
class FMetaXRAcousticMapSceneProxy final : public FDebugRenderSceneProxy {
 public:
  FMetaXRAcousticMapSceneProxy(const UPrimitiveComponent* InComponent);
  FPrimitiveViewRelevance GetViewRelevance(const FSceneView* View) const final;
  void GetDynamicMeshElements(
      const TArray<const FSceneView*>& Views,
      const FSceneViewFamily& ViewFamily,
      uint32 VisibilityMap,
      FMeshElementCollector& Collector) const final;
  bool CanBeOccluded() const final;

 private:
  const UMetaXRAcousticMap* AcousticMapComp = nullptr;
};

void UMetaXRAcousticMap::GenerateFileNameIfEmpty() {
  if (!FilePath.IsEmpty() || GetOwner() == nullptr) {
    return;
  }
  MetaXRAudioUtilities::CreateMetaXRAcousticContentDirectory(META_XR_AUDIO_DEFAULT_SAVE_FOLDER);
  FString LevelName = MetaXRAudioUtilities::GetActorLevelName(GetOwner());
  FString Suggestion = LevelName.IsEmpty() ? GetOwner()->GetActorNameOrLabel() : LevelName;
  FilePath = FPaths::Combine(META_XR_AUDIO_DEFAULT_SAVE_FOLDER, Suggestion + UE_ACOUSTIC_MAP_FILE_EXTENSION);
  METAXR_AUDIO_LOG("No file path specified, using the autogenerated name of: %s", *FilePath);
}

void UMetaXRAcousticMap::CheckIfOnlyMapInLevel() {
  UWorld* World = GetWorld();
  if (World == nullptr) {
    return;
  }

  TArray<FString> LevelsWithMap;
  for (TActorIterator<AActor> ActorItr(World); ActorItr; ++ActorItr) {
    AActor* CurrentActor = *ActorItr;
    UMetaXRAcousticMap* MapComponent = CurrentActor->FindComponentByClass<UMetaXRAcousticMap>();
    if (MapComponent) {
      // Check that this actor does not have multiple acoustic maps attached to it
      TArray<UMetaXRAcousticMap*> MapComponents;
      CurrentActor->GetComponents<UMetaXRAcousticMap>(MapComponents);
      if (MapComponents.Num() > 1) {
        METAXR_AUDIO_LOG_ERROR(
            "There are %i maps on the actor %s, ensure there is only one Acoustic Map per level",
            MapComponents.Num(),
            *CurrentActor->GetActorNameOrLabel());
      }

      // Check that there are no other actors within the level that have an acoustic map
      FString CurrentLevel = MetaXRAudioUtilities::GetActorLevelName(CurrentActor);
      if (LevelsWithMap.Contains(CurrentLevel)) {
        METAXR_AUDIO_LOG_ERROR(
            "An Acoustic Map alreadys exists for the level %s, ensure there is only one Acoustic Map per level", *CurrentLevel);
      } else {
        LevelsWithMap.Add(CurrentLevel);
      }
    }
  }
}

static uint32_t ReportComputeProgress(void* UserData, const char* String, float Progress) {
  UMetaXRAcousticMap* Context = (UMetaXRAcousticMap*)UserData;
  if (Context == nullptr) {
    METAXR_AUDIO_LOG_ERROR("Can't cast user data to MetaXRAcousticMapComponent");
    return false;
  }

  // Get the time since the start of the computation.
  const uint64 ElapsedTime = Context->CheckTimer();

  // Reset the stage starting time if entering a new stage
  if (Context->GetDescription() != String) {
    Context->SetStageStartingTimeSeconds(ElapsedTime);
  }

  Context->SetDescription(String);
  Context->SetComputeProgress(Progress);
  Context->SetComputeTimeSeconds(ElapsedTime - Context->GetStageStartingTimeSeconds());

  return !Context->IsComputeCanceled();
}

void FAsyncSceneMappingTask::DoWork() {
  const FString FilePath = AcousticMapComponent->GetFilePath();
  if (FilePath.IsEmpty()) {
    METAXR_AUDIO_LOG_WARNING("No file path set for acoustic map");
    return;
  }

  AcousticMapComponent->Description = "";
  AcousticMapComponent->ComputeProgress = 0.0f;

  (void)OVRA_CALL(ovrAudio_InitializeAudioSceneIRParameters)(&Parameters);

  // UI is in centimeters but ovrAudio API is in meters
  float UnitScale = 0.01f;
  Parameters.minResolution = AcousticMapComponent->MinSpacing * UnitScale;
  Parameters.maxResolution = AcousticMapComponent->MaxSpacing * UnitScale;
  Parameters.headHeight = AcousticMapComponent->HeadHeight * UnitScale;
  Parameters.maxHeight = AcousticMapComponent->MaxHeight * UnitScale;
  const FVector ovrGravityVector = MetaXRAudioUtilities::ToOVRVector(AcousticMapComponent->GravityVector);
  Parameters.gravityVector[0] = (float)ovrGravityVector.X;
  Parameters.gravityVector[1] = (float)ovrGravityVector.Y;
  Parameters.gravityVector[2] = (float)ovrGravityVector.Z;
  Parameters.reflectionCount = AcousticMapComponent->ReflectionCount;
  Parameters.callbacks.userData = AcousticMapComponent;
  Parameters.callbacks.progress = ReportComputeProgress;
  Parameters.thisSize = sizeof(ovrAudioSceneIRParameters);

  uint32_t flags = 0;
  if (AcousticMapComponent->bStaticOnly)
    flags |= ovrAudioSceneIRFlag_StaticOnly;
  if (AcousticMapComponent->bNoFloating)
    flags |= ovrAudioSceneIRFlag_NoFloating;
  if (AcousticMapComponent->bDiffraction)
    flags |= ovrAudioSceneIRFlag_Diffraction;

  if (bMapOnly) {
    flags |= ovrAudioSceneIRFlag_MapOnly;
    AcousticMapComponent->bHasCustomPoints = false;
  }

  Parameters.flags = static_cast<ovrAudioSceneIRFlags>(flags);

  ovrResult ComputeResult;
  METAXR_AUDIO_LOG("Acoustic Map computation is now being launched on a separate thread");
  if (AcousticMapComponent->bCustomPointsEnabled && !bMapOnly) {
    TArray<FVector3f> Points;
    Points.SetNumUninitialized(AcousticMapComponent->PointsOVR.Num());
    // Cached Points are stored in ovrAudio space without transform applied, so no conversions needed here
    for (int32 i = 0; i < AcousticMapComponent->PointsOVR.Num(); i++) {
      FVector PointD = AcousticMapComponent->PointsOVR[i];
      Points[i] = FVector3f(PointD.X, PointD.Y, PointD.Z);
    }
    ComputeResult =
        OVRA_CALL(ovrAudio_AudioSceneIRComputeCustomPoints)(Map, &Points[0].X, AcousticMapComponent->PointsOVR.Num(), &Parameters);
  } else {
    ComputeResult = OVRA_CALL(ovrAudio_AudioSceneIRCompute)(Map, &Parameters);
  }

  if (ComputeResult != ovrSuccess) {
    if (!AcousticMapComponent->bComputeCanceled) {
      AcousticMapComponent->bComputeFinished = true;
      METAXR_AUDIO_LOG_WARNING("Unable to compute acoustic map %p", Map);
    } else {
      METAXR_AUDIO_LOG_WARNING("Computation for for acoustic map %p was cancelled by the user", Map);
    }
    return;
  } else {
    METAXR_AUDIO_LOG_DISPLAY(
        "Acoustic Map computation has completed successfully for map %p after %f seconds", Map, AcousticMapComponent->CheckTimer());
  }

  ovrAudioSceneIRStatus Status;
  (void)OVRA_CALL(ovrAudio_AudioSceneIRGetStatus)(Map, &Status);

  // Delete the old file first to ensure new result is fresh
  FString FullFilePath = FPaths::ProjectContentDir() / FilePath;
  IPlatformFile& PlatformFile = FPlatformFileManager::Get().GetPlatformFile();
  if (PlatformFile.FileExists(*FullFilePath)) {
    METAXR_AUDIO_LOG_WARNING("Overwriting old acoustic map file at %s", *FullFilePath);
    PlatformFile.DeleteFile(*FullFilePath);
  }
  MetaXRAudioUtilities::CreateMetaXRAcousticContentDirectory(FPaths::GetPath(FilePath));

  // Write the file
  ovrResult Result = OVRA_CALL(ovrAudio_AudioSceneIRWriteFile)(Map, TCHAR_TO_ANSI(*FullFilePath));
  if (Result != ovrSuccess) {
    METAXR_AUDIO_LOG_WARNING("Unable to save acoustic map to file %s", *FullFilePath);
  } else {
    METAXR_AUDIO_LOG_DISPLAY("Successfully saved acoustic map to file %s", *FullFilePath);
  }
}
#endif // if WITH_EDITOR

UMetaXRAcousticMap::UMetaXRAcousticMap() {
  bAutoActivate = true;
  PrimaryComponentTick.bCanEverTick = true;
  bWantsInitializeComponent = true;
  bTickInEditor = true;
#if WITH_EDITOR
  GizmoMeshComponent = CreateDefaultSubobject<UInstancedStaticMeshComponent>(TEXT("GizmoMeshComponent"), true);
#endif
}

void UMetaXRAcousticMap::StartInternal(bool AutoLoad) {
  // Ensure that the IR is not initialized twice.
  if (CachedMap != nullptr) {
    METAXR_AUDIO_LOG_WARNING("Already initialized, skipping init");
    return;
  }

  CheckMapTransformValid();

  // Create the internal Acoustic Map.
  ovrAudioContext OvraContext = nullptr;
  GetOVRAContext(OvraContext, GetOwner());
  check(OvraContext != nullptr);
  const bool ovraCallSuccess = OVRA_CALL(ovrAudio_CreateAudioSceneIR)(OvraContext, &CachedMap) == ovrSuccess;
  if (!ovraCallSuccess) {
    METAXR_AUDIO_LOG_WARNING("Unable to create Acoustic Map data.");
    return;
  }

  // Load the serialized Acoustic Map.
  if (IsPlaymodeActive()) {
    LoadData();
  } else if (AutoLoad) {
    // Create the full file path
    if (FilePath.IsEmpty()) {
      METAXR_AUDIO_LOG_WARNING("No file path is specified for the Acoustic Map");
      return;
    }
    const FString FullFilePath = FPaths::ProjectContentDir() / FilePath;
    // Check if the file exists
    IPlatformFile& PlatformFile = FPlatformFileManager::Get().GetPlatformFile();
    if (!PlatformFile.FileExists(*FullFilePath)) {
      METAXR_AUDIO_LOG_WARNING("The specified file does not exist: %s", *FullFilePath);
      return;
    }

    // Do a blocking load from file when not playing so inspector can update immediately
    if (OVRA_CALL(ovrAudio_AudioSceneIRReadFile)(CachedMap, TCHAR_TO_ANSI(*FullFilePath)) != ovrSuccess) {
      METAXR_AUDIO_LOG_WARNING("Unable to create internal Acoustic Map");
      return;
    } else {
      METAXR_AUDIO_LOG("Successfully loaded Acoustic Map from file %s", *FullFilePath);
#if WITH_EDITOR
      UpdateCachedPoints();
#endif
    }
  }

  ApplyTransform();
}

void UMetaXRAcousticMap::DestroyInternal() {
#if WITH_EDITOR
  // Make sure to stop any compute jobs
  if (bComputing) {
    CancelCompute();
    FinishCompute();
  }
#endif

  if (CachedMap != nullptr) {
    // Destroy the Acoustic Map.
    METAXR_AUDIO_LOG("Destroying Acoustic Map %p", CachedMap);
    if (OVRA_CALL(ovrAudio_DestroyAudioSceneIR)(CachedMap) != ovrSuccess) {
      METAXR_AUDIO_LOG_WARNING("Unable to destroy Acoustic Map");
      return;
    }
    CachedMap = nullptr;
  }
}

void UMetaXRAcousticMap::LoadData() {
  if (FilePath.IsEmpty()) {
    METAXR_AUDIO_LOG_WARNING("No filepath for MetaXRAcousticMap");
    return;
  }

  const FString FullFilePath = FPaths::ProjectContentDir() / FilePath;
#if WITH_EDITOR
  if (!FPaths::FileExists(FullFilePath)) {
    METAXR_AUDIO_LOG_WARNING("Acoustic map file not found: %s", *FullFilePath);
    return;
  }
#endif

  // Read the file data into a byte array
  TArray<uint8> FileData;
  if (!FFileHelper::LoadFileToArray(FileData, *FullFilePath)) {
    METAXR_AUDIO_LOG_WARNING("Failed to load audio acoustic map file: %s", *FullFilePath);
    return;
  }

  ovrResult Result;
  Result = OVRA_CALL(ovrAudio_AudioSceneIRReadMemory)(CachedMap, (const int8_t*)FileData.GetData(), FileData.Num());
  if (Result != ovrSuccess) {
    METAXR_AUDIO_LOG_WARNING("Unable to read audio acoustic map from memory: %s", *FullFilePath);
    return;
  } else {
    METAXR_AUDIO_LOG("Loaded acoustic map from memory: %s to %p", *FullFilePath, CachedMap);
  }

  // Now that the map is loaded ensure that it is enabled
  Result = OVRA_CALL(ovrAudio_AudioSceneIRSetEnabled)(CachedMap, true);
  if (Result != ovrSuccess) {
    METAXR_AUDIO_LOG_WARNING("Failed to enable Acoustic Map %p", CachedMap);
  } else {
    METAXR_AUDIO_LOG("Enabled Acoustic Map: %p", CachedMap);
  }

  // Also ensure the transform is up to date
  ApplyTransform();
}

#if WITH_EDITOR
bool UMetaXRAcousticMap::Compute(bool bMapOnly, bool bBlockingCompute) {
  // Don't allow computing more than once at a time
  if (bComputing) {
    METAXR_AUDIO_LOG_WARNING("Cannot compute: computation in progress");
    return false;
  }

  if (GetOwner() == nullptr)
    return false;

  if (IsPlaymodeActive()) {
    METAXR_AUDIO_LOG_WARNING("Cannot compute: application is playing");
    return false;
  }

  // Make sure we are initialized.
  StartInternal(false);
  ApplyTransform();
  // Gather Geometries and Materials
  GatherGeometriesAndMaterials();

  // Collect all the file names to checkout in source control, both this Map and Geo files
  // Note this is done here because it must be done before attempting to write to file (perforce is read only until checked out)
  TArray<FString> FilePathsToCheckout;
  FString FullFilePath = FPaths::ProjectContentDir() / FilePath;
  FilePathsToCheckout.Add(FullFilePath);

  // Upload all geometries and materials
  Hash = FString(); // empty hash for this new computation
  TMap<FString, TArray<FString>> GeometryFileNames;
  const UMetaXRAcousticProjectSettings* Settings = GetDefault<UMetaXRAcousticProjectSettings>();
  for (UMetaXRAcousticGeometry* GeometryComponent : Geometries) {
    // Start up each geometry component to prepare for the map bake
    if (!GeometryComponent->StartInternal()) {
      DestroyInternal();
      // Don't leave any geometries we attempted to start hanging
      for (UMetaXRAcousticGeometry* Geo : Geometries) {
        Geo->DestroyInternal();
      }
      return false;
    }

    // Keep track of the number of geometries so we don't try to bake an empty scene
    Hash.Append(GeometryComponent->ComputeHash());

    // Keep track of which geometry files have been used so far
    FString GeometryFileName = GeometryComponent->GetFilePath();
    if (GeometryComponent->GetOwner()) {
      if (!GeometryFileNames.Contains(GeometryFileName)) {
        GeometryFileNames.Add(GeometryFileName);
      }
      GeometryFileNames[GeometryFileName].Add(GeometryComponent->GetOwner()->GetActorNameOrLabel());
    }

    // Record if this geometry needed to be checked out in source control
    if (GeometryComponent->IsFileEnabled() && Settings->bMapBakeWriteGeo) {
      FilePathsToCheckout.Add(FPaths::ProjectContentDir() / GeometryComponent->GetFilePath());
    }
  }

  for (UMetaXRAcousticMaterial* MaterialComponent : Materials) {
    // Hash materials (Note we don't need to StartInternal() for the material as that happens internal to geometry startup)
    MaterialComponent->AppendHash(Hash);
  }

  if (Geometries.Num() == 0) {
    METAXR_AUDIO_LOG_WARNING("Precompute failed: No geometry");
    DestroyInternal();
    return false;
  }

  // Warn the user if they have multiple geometries that have the same file name as this could cause only one of them to load
  for (const TPair<FString, TArray<FString>>& GeometryNames : GeometryFileNames) {
    FString UniqueFileName = GeometryNames.Key;
    TArray<FString> ComponentsUsingName = GeometryNames.Value;
    if (ComponentsUsingName.Num() > 1) {
      METAXR_AUDIO_LOG_WARNING(
          "There are multiple geometry components with the file name %s. This could cause overwriting and therefore not loading some geometry",
          *UniqueFileName);
      for (FString DuplicateGeometryComponent : ComponentsUsingName) {
        METAXR_AUDIO_LOG_WARNING("Component %s has a duplicate file name %s", *DuplicateGeometryComponent, *UniqueFileName);
      }
    }
  }

  // Perform the source control checkout before the computation and writing of files
  MetaXRAudioUtilities::CheckOutFilesInSourceControl(FilePathsToCheckout);

  // Initialize the scene and start the job on the background thread.
  bComputing = true;
  bComputeCanceled = false;
  bComputeFinished = false;
  bComputeSucceeded = false;

  if (MappingTask) {
    bComputeFinished = true;
    bComputeCanceled = true;
    MappingTask->Cancel();
    MappingTask->EnsureCompletion();
    MappingTask.Reset();
    DestroyInternal();
    return false;
  }

  StartTimer();
  bComputeCanceled = false;
  MappingTask = MakeShareable(new FAsyncTask<FAsyncSceneMappingTask>(this, CachedMap, MapParameters));
  MappingTask->GetTask().bMapOnly = bMapOnly;
  MappingTask->StartBackgroundTask();

  // This prevents the engine from proceeding to the next step until the compute has finished on its thread
  // This is used for bulk baking where each bake must complete before opening the next level
  if (bBlockingCompute) {
    MappingTask->EnsureCompletion();
    FinishCompute();
  }

  return true;
}

/// Do final cleanup that can't be done on the async thread.
/**
 * This is called by the custom editor from the main thread
 * after this.computeFinished == true. Don't call it otherwise.
 */
void UMetaXRAcousticMap::FinishCompute() {
  if (MappingTask != nullptr) {
    // Wait until the compute thread is done.
    // Usually it is already finished by now, but in case of early termination (e.g. via OnDestroy()), we need to wait.
    MappingTask->EnsureCompletion();
  }

  UpdateCachedPoints();
  // Setup the file paths for the output file.
  GenerateFileNameIfEmpty();
  const FString FullFilePath = FPaths::ProjectContentDir() / FilePath;

  // Write IR to a file
  if (bComputeSucceeded && !bComputeCanceled) {
    if (OVRA_CALL(ovrAudio_AudioSceneIRWriteFile)(CachedMap, TCHAR_TO_ANSI(*FullFilePath)) != ovrSuccess) {
      METAXR_AUDIO_LOG_WARNING("Error writing Acoustic Map to file");
    } else {
      METAXR_AUDIO_LOG_DISPLAY("Acoustic Map finished generating to %s", *FullFilePath);
    }
  }

  // Signal that the compute is finished.
  // This must be before the call to sceneIR.DestroyInternal() below to prevent stack overflow.
  bComputeFinished = true;
  bComputing = false;

  // Clean up scene objects.
  DestroyInternal();

  // Collect all the file names to checkout in source control, both this Map and Geo files
  TArray<FString> FilePathsToCheckout;
  FilePathsToCheckout.Add(FullFilePath);

  // Clean up geometry and materials. Write to file first if this setting is enabled
  const UMetaXRAcousticProjectSettings* Settings = GetDefault<UMetaXRAcousticProjectSettings>();
  for (UMetaXRAcousticGeometry* GeometryComponent : Geometries) {
    if (GeometryComponent->IsFileEnabled() && Settings->bMapBakeWriteGeo && !bComputeCanceled) {
      GeometryComponent->WriteFileInternal(GeometryComponent->GetHandle());
      FilePathsToCheckout.Add(FPaths::ProjectContentDir() / GeometryComponent->GetFilePath());
    }
    GeometryComponent->DestroyInternal();
  }

  MetaXRAudioUtilities::CheckOutFilesInSourceControl(FilePathsToCheckout);

  // Reset for next time.
  MappingTask.Reset();

  // This exists to fix an issue with point gizmos disapearing immediately after first bake.
  // After hitting 'Bake Acoustics' button in detail panel (FMetaXRAcousticMapDetails::CustomizeDetails) for first time
  // with no previous bake data...
  {
    AActor* AcousticMapActor = GetOwner();
    if (!AcousticMapActor)
      return;

    AcousticMapActor->UpdateComponentTransforms();
  }
}

// Gather all geometry and materials in the level in their respective lists
void UMetaXRAcousticMap::GatherGeometriesAndMaterials() {
  TArray<UMetaXRAcousticGeometry*> GeometryList;
  TArray<UMetaXRAcousticMaterial*> MaterialList;
  UWorld* World = GetWorld();
  const UMetaXRAcousticProjectSettings* Settings = GetDefault<UMetaXRAcousticProjectSettings>();
  for (TActorIterator<AActor> ActorItr(World); ActorItr; ++ActorItr) {
    AActor* CurrentActor = *ActorItr;
    UMetaXRAcousticGeometry* GeometryComponent = CurrentActor->FindComponentByClass<UMetaXRAcousticGeometry>();
    if (GeometryComponent) {
      GeometryList.Add(GeometryComponent);
    }

    UMetaXRAcousticMaterial* MaterialComponent = CurrentActor->FindComponentByClass<UMetaXRAcousticMaterial>();
    if (MaterialComponent) {
      MaterialList.Add(MaterialComponent);
    }
  }
  Geometries = GeometryList;
  Materials = MaterialList;
}

void UMetaXRAcousticMap::UpdateCachedPoints() {
  // Don't update the visualizer if the bake was cancelled
  if (bComputeCanceled)
    return;

  size_t NewPointCount = 0;
  if (OVRA_CALL(ovrAudio_AudioSceneIRGetPointCount)(CachedMap, &NewPointCount) != ovrSuccess) {
    METAXR_AUDIO_LOG_WARNING("Failed to get point count of map %p", CachedMap);
  }

  TArray<float> Points;
  Points.SetNumUninitialized(NewPointCount * 3);
  if (OVRA_CALL(ovrAudio_AudioSceneIRGetPoints)(CachedMap, Points.GetData(), NewPointCount) != ovrSuccess) {
    METAXR_AUDIO_LOG_WARNING("Failed to get points of map %p", CachedMap);
  }

  ovrAudioSceneIRStatus NewStatus;
  if (OVRA_CALL(ovrAudio_AudioSceneIRGetStatus)(CachedMap, &NewStatus) != ovrSuccess) {
    METAXR_AUDIO_LOG_WARNING("Failed to get status of map %p", CachedMap);
  }
  Status = static_cast<EAcousticMapStatus>(NewStatus);

  // Keep map points stored in ovrAudio axis with no acoustic map transform applied
  SetGizmoPoints(MoveTemp(Points), NewPointCount);
}

/// Signal to the precomputation thread that it should stop computing the IR
void UMetaXRAcousticMap::CancelCompute() {
  bComputeCanceled = true;
}
#endif

void UMetaXRAcousticMap::OnRegister() {
  Super::OnRegister();
#if WITH_EDITOR
  CheckIfOnlyMapInLevel();
  GenerateFileNameIfEmpty();
  SetupGizmoMeshComponent();
#endif

  CheckMapTransformValid();
  StartInternal();
  if (!IsPlaymodeActive())
    DestroyInternal();
}

void UMetaXRAcousticMap::OnUnregister() {
  Super::OnUnregister();
  DestroyInternal();
}

void UMetaXRAcousticMap::BeginDestroy() {
  Super::BeginDestroy();

#if WITH_EDITOR
  if (MappingTask) {
    bComputeCanceled = true;
    MappingTask->Cancel();
    MappingTask->EnsureCompletion();
    MappingTask.Reset();
  }
  if (AcousticMapCVarDH.IsValid()) {
    IConsoleVariable* MetaXRAudioMapGizmoCVAR = IConsoleManager::Get().FindConsoleVariable(TEXT("MetaXRAudioGizmos.Maps"));
    auto& ConsoleVarDelegate = MetaXRAudioMapGizmoCVAR->OnChangedDelegate();
    ConsoleVarDelegate.Remove(AcousticMapCVarDH);
  }
  if (GlobalMetaCVarDH.IsValid()) {
    IConsoleVariable* MetaXRAudioGlobalGizmoCVAR = IConsoleManager::Get().FindConsoleVariable(TEXT("MetaXRAudioGizmos"));
    auto& ConsoleVarDelegate = MetaXRAudioGlobalGizmoCVAR->OnChangedDelegate();
    ConsoleVarDelegate.Remove(GlobalMetaCVarDH);
  }
#endif

  DestroyInternal();
}

void UMetaXRAcousticMap::ApplyTransform() {
  CheckMapTransformValid();
  const FTransform& UETransform = GetComponentTransform();
  float OVRTransform[16];
  MetaXRAudioUtilities::ConvertUETransformToOVRTransform(UETransform, OVRTransform);

#if WITH_EDITOR
  // Warn user in editor if the transform has any scaling (not allowed).
  FVector Scale = UETransform.GetScale3D();
  float Epsilon = 0.000001f;
  if (fabs(fabs(Scale.X) - 1.0f) > Epsilon || fabs(fabs(Scale.Y) - 1.0f) > Epsilon || fabs(fabs(Scale.Z) - 1.0f) > Epsilon) {
    METAXR_AUDIO_LOG_ERROR(
        "Acoustic Map object transform cannot have any scaling. This may result in incorrect audio.\nCurrent scale = {%f, %f, %f}",
        Scale.X,
        Scale.Y,
        Scale.Z);
  }
#endif

  if (OVRA_CALL(ovrAudio_AudioSceneIRSetTransform)(CachedMap, OVRTransform) != ovrSuccess) {
    METAXR_AUDIO_LOG("Failed to set transform for Acoustic Map %p", CachedMap);
  } else {
    METAXR_AUDIO_LOG("Set transform for Acoustic Map %p", CachedMap);
  }

  PreviousTransform = UETransform;
}

bool UMetaXRAcousticMap::IsPlaymodeActive() const {
  return MetaXRAudioUtilities::PlayModeActive(GetWorld());
}

// We do not allow UMapComponent transformations as we want our Map to stay in sync with expectations
void UMetaXRAcousticMap::CheckMapTransformValid() {
  if (GetOwner() == nullptr) {
    return;
  }
  if (!GetOwner()->GetTransform().Equals(GetComponentTransform())) {
    METAXR_AUDIO_LOG_WARNING(
        "You cannot change the transform of the UMapComponent, only the transform of its attched Aactor. This ensures the audio map stays in sync with the physical geometry.");
    ResetRelativeTransform();
  }
}

FPrimitiveSceneProxy* UMetaXRAcousticMap::CreateSceneProxy() {
#if WITH_EDITOR_GIZMOS
  return new FMetaXRAcousticMapSceneProxy(this);
#else
  return nullptr;
#endif
}

void UMetaXRAcousticMap::TickComponent(float DeltaTime, enum ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) {
  Super::TickComponent(DeltaTime, TickType, ThisTickFunction);

#if WITH_EDITOR
  if (bComputing) {
    // Try to get rid of the thread if the user cancelled
    if (bComputeCanceled && !MappingTask->IsDone())
      MappingTask->TryAbandonTask();

    // Poll to see if the async compute was finished.
    if (MappingTask->IsDone() || bComputeFinished) {
      bool wasCancelled = bComputeCanceled;
      // Do final cleanup on the main thread after computing the IR.
      FinishCompute();
      if (wasCancelled) {
        METAXR_AUDIO_LOG_WARNING("Attempting to load previous bake %s", *FilePath);
        DestroyInternal();
        StartInternal();
      }
    }
  }
#endif

  const FTransform& Transform = GetComponentTransform();
  if (!Transform.Equals(PreviousTransform))
    ApplyTransform();
}

#if WITH_EDITOR
FBoxSphereBounds UMetaXRAcousticMap::CalcBounds(const FTransform& LocalToWorld) const {
  return Super::CalcBounds(LocalToWorld);
}

void UMetaXRAcousticMap::PostEditChangeProperty(struct FPropertyChangedEvent& PropertyChangedEvent) {
  CheckMapTransformValid();
  // Must be called after our updated above in order to make sure everythings updated correctly.
  Super::PostEditChangeProperty(PropertyChangedEvent);
}

void UMetaXRAcousticMap::PostEditComponentMove(bool bFinished) {
  ApplyTransform();
}

void UMetaXRAcousticMap::Activate(bool bReset) {
  if (CachedMap == nullptr) {
    return;
  }

  ovrResult Result;
  Result = OVRA_CALL(ovrAudio_AudioSceneIRSetEnabled)(CachedMap, true);
  if (Result != ovrSuccess) {
    METAXR_AUDIO_LOG_WARNING("Failed to Set Acoustic Map %p to enabled", CachedMap);
  } else {
    METAXR_AUDIO_LOG("Set Acoustic Map %p to enabled", CachedMap);
  }
}

void UMetaXRAcousticMap::Deactivate() {
  ovrResult Result;
  Result = OVRA_CALL(ovrAudio_AudioSceneIRSetEnabled)(CachedMap, false);
  if (Result != ovrSuccess) {
    METAXR_AUDIO_LOG_WARNING("Failed to Set Acoustic Map %p to disabled", CachedMap);
  } else {
    METAXR_AUDIO_LOG("Set Acoustic Map %p to disabed", CachedMap);
  }
}

FVector UMetaXRAcousticMap::GetNewPointForRay(const FVector& RayOrigin, const FVector& RayDirection) const {
  constexpr float DefaultDistance = 400.0f; // How far away to place a point if the ray hits nothing
  constexpr float TraceDistance = 60000.0f; // How far away to fire the ray trace before giving up
  const FVector EndPosition = RayOrigin + (RayDirection * TraceDistance); // The point at the end of our longest possible ray

  // Try to perform raytracing to find a point in front of the camera that is not blocked by geometry.
  FVector NewPointPosition;
  UWorld* World = GetWorld();
  if (World != nullptr) {
    // Setup variables for unreal's raytracing function
    FHitResult HitResult;
    FCollisionObjectQueryParams ObjectTypes;
    ObjectTypes.AddObjectTypesToQuery(ECC_WorldStatic);
    ObjectTypes.AddObjectTypesToQuery(ECC_WorldDynamic);
    FCollisionQueryParams QueryParams;

    // Perform a single raytrace which will tell us the first blocking hit.
    bool HitFound = World->LineTraceSingleByObjectType(HitResult, RayOrigin, EndPosition, ObjectTypes, QueryParams);
    if (HitResult.bBlockingHit && IsValid(HitResult.GetActor())) {
      // Place the point slightly away from the hit point to avoid placing points on walls.
      float bias = 300.0f;
      NewPointPosition = RayOrigin + (RayDirection * FMath::Max(HitResult.Distance - bias, 0.0f));

      if (bNoFloating == false) {
        return NewPointPosition;
      }

      // Trace two rays down and up to place the point at the right height.
      FVector DownRayEndPosition = NewPointPosition + (GravityVector.GetUnsafeNormal() * TraceDistance);
      if (World->LineTraceSingleByObjectType(HitResult, NewPointPosition, DownRayEndPosition, ObjectTypes, QueryParams)) {
        float downDistance = HitResult.Distance;
        float targetHeight = NewPointPosition.Z;

        if (downDistance > MaxHeight) {
          targetHeight = HeadHeight;
        } else if (downDistance < HeadHeight) {
          FVector UpRayEndPosition = NewPointPosition - (GravityVector.GetUnsafeNormal() * TraceDistance);
          if (World->LineTraceSingleByObjectType(HitResult, NewPointPosition, UpRayEndPosition, ObjectTypes, QueryParams)) {
            // Move point so that it is either at head height or is at the floor/ceiling midpoint if that is less.
            float midHeight = 0.5f * (downDistance + HitResult.Distance);
            targetHeight = FMath::Min(HeadHeight, midHeight);
          }
        }

        // height adjustment
        NewPointPosition += GravityVector * (downDistance - targetHeight);
      }
      return NewPointPosition;
    } else {
      // Facing empty space, place the point slightly in front of the camera.
      return RayOrigin + (RayDirection * DefaultDistance);
    }
  }

  // Place slightly in front of camera as fallback if cannot raytrace or we didn't hit anything
  return RayOrigin + (RayDirection * DefaultDistance);
}

#pragma region GIZMO
bool IsGizmoVisible() {
  static const IConsoleVariable* const MetaXRAudioGlobalGizmoCVAR = IConsoleManager::Get().FindConsoleVariable(TEXT("MetaXRAudioGizmos"));
  static const IConsoleVariable* const MetaXRAudioMapGizmoCVAR = IConsoleManager::Get().FindConsoleVariable(TEXT("MetaXRAudioGizmos.Maps"));
  return MetaXRAudioMapGizmoCVAR && MetaXRAudioMapGizmoCVAR->GetInt() != 0 && MetaXRAudioGlobalGizmoCVAR &&
      MetaXRAudioGlobalGizmoCVAR->GetInt() != 0;
}

constexpr float GetGizmoPointScale() {
  return 0.05f;
}

FVector GetGizmoPointScaleVector() {
  return GetGizmoPointScale() * FVector::One();
}

int UMetaXRAcousticMap::GetGizmoPointCount() const {
  return PointsOVR.Num();
}

bool UMetaXRAcousticMap::IsGizmoPointSelected() const {
  return PointsOVR.IsValidIndex(SelectedPointIndex);
}

bool UMetaXRAcousticMap::HasGizmoPoints() const {
  return !PointsOVR.IsEmpty();
}

FVector UMetaXRAcousticMap::GetGizmoPointUE(int PointIndex) const {
  if (!PointsOVR.IsValidIndex(PointIndex)) {
    METAXR_AUDIO_LOG_WARNING("[UMetaXRAcousticMap::GetGizmoPointUE] Attempting to get Gizmo point with invalid index");
    return FVector::Zero();
  }
  return GetComponentTransform().TransformPosition(MetaXRAudioUtilities::ToUEVector(PointsOVR[PointIndex]));
}

TArray<FVector> UMetaXRAcousticMap::GetGizmoPointsUE() const {
  TArray<FVector> ReturnArray;
  for (int i = 0; i < PointsOVR.Num(); i++)
    ReturnArray.Add(GetGizmoPointUE(i));
  return ReturnArray;
}

FVector UMetaXRAcousticMap::GetSelectedGizmoPointUE() const {
  return GetGizmoPointUE(SelectedPointIndex);
}

float UMetaXRAcousticMap::GetGizmoSphereRadiusWS() const {
  // no need to worry about multiple threads attempting to init here...
  static float GizmoSphereRadiusWS = -1.0f;
  if (GizmoSphereRadiusWS > 0)
    return GizmoSphereRadiusWS;

  if (!IsValid(GizmoMeshComponent))
    return -1.0f;

  const TObjectPtr<const UStaticMesh> SphereMesh = GizmoMeshComponent->GetStaticMesh();
  if (!IsValid(SphereMesh))
    return -1.0f;

  const FSphere BoundingSphere = SphereMesh->GetBounds().GetSphere();
  const float RadiusObjSpace = BoundingSphere.W;
  // we only use uniform scale for gizmo points
  GizmoSphereRadiusWS = GetGizmoPointScale() * RadiusObjSpace;
  return GizmoSphereRadiusWS;
}

void UMetaXRAcousticMap::AddGizmoPoint(const FVector& PointUE) {
  const FTransform& AcousticMapTransform = GetComponentTransform();
  const FVector OVRPoint = MetaXRAudioUtilities::ToOVRVector(AcousticMapTransform.InverseTransformPosition(PointUE));
  PointsOVR.Add(OVRPoint);

  // We need to keep PointsOVR and GizmoMeshComponent synchronized...
  const FTransform GizmoPointTransform(FRotator{}, PointUE, GetGizmoPointScaleVector());
  GizmoMeshComponent->AddInstance(GizmoPointTransform, true);

  const int32 InstanceCount = GizmoMeshComponent->GetInstanceCount();
  const int32 GizmoPointCount = PointsOVR.Num();
  check(InstanceCount == GizmoPointCount);
}

void UMetaXRAcousticMap::RemoveGizmoPoint(const int PointIndex) {
  PointsOVR.RemoveAt(PointIndex);
  check(GizmoMeshComponent->RemoveInstance(PointIndex));
  const int32 InstanceCount = GizmoMeshComponent->GetInstanceCount();
  const int32 GizmoPointCount = PointsOVR.Num();
  check(InstanceCount == GizmoPointCount);
}

void UMetaXRAcousticMap::RemoveSelectedGizmoPoint() {
  if (!PointsOVR.IsValidIndex(SelectedPointIndex)) {
    METAXR_AUDIO_LOG_ERROR("[UMetaXRAcousticMap::RemoveSelectedGizmoPoint] Attempting to remove selected gizmo point with invalid index");
    return;
  }

  PointsOVR.RemoveAt(SelectedPointIndex);
  check(GizmoMeshComponent->RemoveInstance(SelectedPointIndex));
  const int32 InstanceCount = GizmoMeshComponent->GetInstanceCount();
  const int32 GizmoPointCount = PointsOVR.Num();
  check(InstanceCount == GizmoPointCount);

  SetGizmoSelectedPoint(0);
}

void UMetaXRAcousticMap::MoveSelectedGizmoPoint(const FVector& NewLocationUE) {
  if (!IsGizmoPointSelected())
    return;

  const FTransform& AcousticMapTransform = GetComponentTransform();
  PointsOVR[SelectedPointIndex] = MetaXRAudioUtilities::ToOVRVector(AcousticMapTransform.InverseTransformPosition(NewLocationUE));

  const FTransform GizmoPointTransform(FRotator{}, NewLocationUE, GetGizmoPointScaleVector());
  check(GizmoMeshComponent->UpdateInstanceTransform(SelectedPointIndex, GizmoPointTransform, true));

  const int32 InstanceCount = GizmoMeshComponent->GetInstanceCount();
  const int32 GizmoPointCount = PointsOVR.Num();
  check(InstanceCount == GizmoPointCount);
}

void UMetaXRAcousticMap::SetGizmoPoints(TArray<float>&& NewPointsOVR, const int NumPoints) {
  GizmoMeshComponent->ClearInstances();
  PointsOVR.SetNumUninitialized(NumPoints);
  TArray<FTransform> GizmoPointTransforms;
  GizmoPointTransforms.Reserve(NumPoints);
  const FTransform& AcousticMapTransform = GetComponentTransform();
  for (int32 i = 0; i < NumPoints; i++) {
    const FVector OVRPoint(NewPointsOVR[i * 3], NewPointsOVR[i * 3 + 1], NewPointsOVR[i * 3 + 2]);
    PointsOVR[i] = OVRPoint;
    const FVector NewGizmoPointWS = AcousticMapTransform.TransformPosition(MetaXRAudioUtilities::ToUEVector(OVRPoint));
    GizmoPointTransforms.Add(FTransform(FRotator(), NewGizmoPointWS, GetGizmoPointScaleVector()));
  }

  GizmoMeshComponent->AddInstances(GizmoPointTransforms, false, true);

  GizmoMeshComponent->SetVisibility(NumPoints > 0 && IsGizmoVisible(), true);
  const int32 InstanceCount = GizmoMeshComponent->GetInstanceCount();
  const int32 GizmoPointCount = PointsOVR.Num();
  check(InstanceCount == GizmoPointCount);
}

void UMetaXRAcousticMap::SetGizmoSelectedPoint(const int SelectedPoint) {
  if (!PointsOVR.IsValidIndex(SelectedPoint)) {
    METAXR_AUDIO_LOG_ERROR("[UMetaXRAcousticMap::SetGizmoSelectedPoint] Attempting to select gizmo point with invalid index");
    return;
  }
  SelectedPointIndex = SelectedPoint;
}

void UMetaXRAcousticMap::ResetGizmoSelectedPoint() {
  SelectedPointIndex = -1;
}

void UMetaXRAcousticMap::SetupGizmoMeshComponent() {
  GizmoMeshComponent->SetMobility(EComponentMobility::Movable);
  GizmoMeshComponent->RegisterComponent();
  GizmoMeshComponent->AttachToComponent(this, FAttachmentTransformRules::KeepRelativeTransform);
  GizmoMeshComponent->bIsEditorOnly = true;
  GizmoMeshComponent->bSelectable = true;
  const bool ShouldVizGizmo = IsGizmoVisible();
  GizmoMeshComponent->SetVisibility(ShouldVizGizmo, true);
  GizmoMeshComponent->SetCollisionEnabled(ECollisionEnabled::NoCollision);
  GizmoMeshComponent->SetCastShadow(false);
  GizmoMeshComponent->SetGenerateOverlapEvents(false);
  GizmoMeshComponent->SetCanEverAffectNavigation(false);
  UStaticMesh* GizmoMesh = LoadObject<UStaticMesh>(GetOuter(), TEXT("/Engine/EditorMeshes/EditorSphere.EditorSphere"));
  check(GizmoMesh != nullptr);
  GizmoMeshComponent->SetStaticMesh(GizmoMesh);

  GizmoMaterialPtr = UMaterialInstanceDynamic::Create(GEngine->DebugMeshMaterial, GetOuter());
  GizmoMaterialPtr->SetVectorParameterValue(TEXT("Color"), FLinearColor::Yellow);
  GizmoMeshComponent->SetMaterial(0, GizmoMaterialPtr);

  // Needed to turn on/off the InstancedStaticMeshcomponent when the cvar states change.
  IConsoleVariable* MetaXRAudioMapGizmoCVAR = IConsoleManager::Get().FindConsoleVariable(TEXT("MetaXRAudioGizmos.Maps"));
  check(MetaXRAudioMapGizmoCVAR != nullptr);
  IConsoleVariable* MetaXRAudioGlobalGizmoCVAR = IConsoleManager::Get().FindConsoleVariable(TEXT("MetaXRAudioGizmos"));
  check(MetaXRAudioGlobalGizmoCVAR != nullptr) auto& ConsoleVarDelegate = MetaXRAudioMapGizmoCVAR->OnChangedDelegate();
  AcousticMapCVarDH = ConsoleVarDelegate.AddUObject(this, &UMetaXRAcousticMap::OnCVarStateChanged);
  auto& GlobalConsoleVarDelegate = MetaXRAudioGlobalGizmoCVAR->OnChangedDelegate();
  GlobalMetaCVarDH = GlobalConsoleVarDelegate.AddUObject(this, &UMetaXRAcousticMap::OnCVarStateChanged);
}

void UMetaXRAcousticMap::OnCVarStateChanged(IConsoleVariable* CVar) {
  check(GizmoMeshComponent != nullptr);
  GizmoMeshComponent->SetVisibility(IsGizmoVisible(), true);
}
#pragma endregion

#pragma region PROXY
FMetaXRAcousticMapSceneProxy::FMetaXRAcousticMapSceneProxy(const UPrimitiveComponent* InComponent) : FDebugRenderSceneProxy(InComponent) {
  AcousticMapComp = CastChecked<UMetaXRAcousticMap>(InComponent);
}

FPrimitiveViewRelevance FMetaXRAcousticMapSceneProxy::GetViewRelevance(const FSceneView* View) const {
  FPrimitiveViewRelevance Result;
  Result.bDrawRelevance = true;
  Result.bDynamicRelevance = true;
  return Result;
}

void FMetaXRAcousticMapSceneProxy::GetDynamicMeshElements(
    const TArray<const FSceneView*>& Views,
    const FSceneViewFamily& ViewFamily,
    uint32 VisibilityMap,
    FMeshElementCollector& Collector) const {}

bool FMetaXRAcousticMapSceneProxy::CanBeOccluded() const {
  return false;
}

#pragma endregion

#endif // WITH_EDITOR
